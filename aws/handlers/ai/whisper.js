/**
 * AWS Lambda Handler for Whisper AI Transcription
 * HIPAA-compliant audio transcription and translation services
 */

const { S3Client, GetObjectCommand, PutObjectCommand } = require('@aws-sdk/client-s3');
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, PutCommand } = require('@aws-sdk/lib-dynamodb');
const { SSMClient, GetParameterCommand } = require('@aws-sdk/client-ssm');

// Initialize AWS clients
const s3Client = new S3Client({ region: process.env.AWS_REGION });
const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });
const dynamoDB = DynamoDBDocumentClient.from(dynamoClient);
const ssmClient = new SSMClient({ region: process.env.AWS_REGION });

/**
 * CORS headers for healthcare API compliance
 */
const corsHeaders = {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': process.env.CORS_ORIGIN || '*',
  'Access-Control-Allow-Headers': 'Content-Type,Authorization,Accept',
  'Access-Control-Allow-Methods': 'POST,OPTIONS',
  'Cache-Control': 'no-cache, no-store, must-revalidate',
  'X-Content-Type-Options': 'nosniff'
};

/**
 * Get Whisper API key from SSM Parameter Store
 */
async function getWhisperApiKey() {
  try {
    const result = await ssmClient.send(new GetParameterCommand({
      Name: process.env.WHISPER_API_KEY_PARAMETER || '/webqx/dev/whisper-api-key',
      WithDecryption: true
    }));
    return result.Parameter.Value;
  } catch (error) {
    console.error('Failed to get Whisper API key:', error);
    throw new Error('Failed to retrieve API key');
  }
}

/**
 * Validate supported audio formats and languages
 */
function validateTranscriptionRequest(data) {
  const supportedFormats = ['mp3', 'mp4', 'wav', 'm4a', 'webm'];
  const supportedLanguages = ['en', 'es', 'fr', 'de', 'pt', 'zh', 'ar', 'hi', 'ja'];
  
  if (!data.audioData && !data.audioUrl) {
    return { valid: false, error: 'Audio data or URL is required' };
  }
  
  if (data.language && !supportedLanguages.includes(data.language)) {
    return { valid: false, error: `Unsupported language: ${data.language}` };
  }
  
  return { valid: true };
}

/**
 * Mock Whisper transcription (replace with actual OpenAI Whisper API call)
 */
async function transcribeAudio(audioData, options = {}) {
  // This is a mock implementation for demonstration
  // In production, replace with actual OpenAI Whisper API call
  
  const mockTranscriptions = {
    'healthcare-audio-1': {
      text: "Patient reports chest pain for the past 2 hours. Pain is described as sharp and radiating to the left arm. No shortness of breath. Vital signs are stable.",
      segments: [
        { start: 0.0, end: 3.5, text: "Patient reports chest pain for the past 2 hours." },
        { start: 3.5, end: 7.8, text: "Pain is described as sharp and radiating to the left arm." },
        { start: 7.8, end: 10.2, text: "No shortness of breath." },
        { start: 10.2, end: 12.0, text: "Vital signs are stable." }
      ],
      language: options.language || 'en',
      confidence: 0.95
    },
    'default': {
      text: "This is a sample transcription of the audio content. The actual transcription would be generated by OpenAI Whisper API.",
      segments: [
        { start: 0.0, end: 5.0, text: "This is a sample transcription of the audio content." },
        { start: 5.0, end: 10.0, text: "The actual transcription would be generated by OpenAI Whisper API." }
      ],
      language: options.language || 'en',
      confidence: 0.85
    }
  };
  
  // Simulate API processing time
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  const transcription = mockTranscriptions[options.audioId] || mockTranscriptions['default'];
  
  return transcription;
}

/**
 * Translate text using mock translation service
 */
async function translateText(text, targetLanguage) {
  // Mock translation service (replace with actual translation API)
  const translations = {
    'es': {
      'Take 2 tablets daily': 'Tomar 2 tabletas al día',
      'Patient reports chest pain': 'El paciente reporta dolor en el pecho',
      'Vital signs are stable': 'Los signos vitales son estables'
    },
    'fr': {
      'Take 2 tablets daily': 'Prendre 2 comprimés par jour',
      'Patient reports chest pain': 'Le patient signale une douleur thoracique',
      'Vital signs are stable': 'Les signes vitaux sont stables'
    }
  };
  
  // Simulate API processing time
  await new Promise(resolve => setTimeout(resolve, 500));
  
  const targetTranslations = translations[targetLanguage];
  if (targetTranslations && targetTranslations[text]) {
    return {
      translatedText: targetTranslations[text],
      sourceLanguage: 'en',
      targetLanguage,
      confidence: 0.92
    };
  }
  
  // Fallback translation with language prefix
  const prefixes = { 'es': '[ES]', 'fr': '[FR]', 'de': '[DE]' };
  const prefix = prefixes[targetLanguage] || `[${targetLanguage.toUpperCase()}]`;
  
  return {
    translatedText: `${prefix} ${text}`,
    sourceLanguage: 'en',
    targetLanguage,
    confidence: 0.75
  };
}

/**
 * Store transcription result in DynamoDB
 */
async function storeTranscription(transcriptionData) {
  const item = {
    id: `transcription-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    timestamp: new Date().toISOString(),
    ...transcriptionData,
    ttl: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60) // 1 year retention
  };
  
  try {
    await dynamoDB.send(new PutCommand({
      TableName: process.env.TRANSCRIPTIONS_TABLE,
      Item: item
    }));
    
    return item.id;
  } catch (error) {
    console.error('Failed to store transcription:', error);
    throw error;
  }
}

/**
 * Main Lambda handler
 */
exports.handler = async (event) => {
  console.log('Whisper transcription event:', JSON.stringify(event, null, 2));
  
  try {
    const { httpMethod, path, body } = event;
    
    // Handle OPTIONS request for CORS
    if (httpMethod === 'OPTIONS') {
      return {
        statusCode: 200,
        headers: corsHeaders,
        body: ''
      };
    }
    
    if (httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers: corsHeaders,
        body: JSON.stringify({ error: 'Method not allowed' })
      };
    }
    
    const requestData = JSON.parse(body || '{}');
    
    // Route to appropriate handler
    if (path.includes('/transcribe')) {
      return await handleTranscription(requestData);
    } else if (path.includes('/translate')) {
      return await handleTranslation(requestData);
    } else {
      return {
        statusCode: 404,
        headers: corsHeaders,
        body: JSON.stringify({ error: 'Endpoint not found' })
      };
    }
    
  } catch (error) {
    console.error('Error processing Whisper request:', error);
    
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ 
        error: 'Internal server error',
        message: error.message 
      })
    };
  }
};

/**
 * Handle audio transcription
 */
async function handleTranscription(requestData) {
  try {
    const validation = validateTranscriptionRequest(requestData);
    if (!validation.valid) {
      return {
        statusCode: 400,
        headers: corsHeaders,
        body: JSON.stringify({ error: validation.error })
      };
    }
    
    const { audioData, audioUrl, language, sessionId, patientId } = requestData;
    
    // Transcribe audio
    const transcription = await transcribeAudio(audioData || audioUrl, {
      language,
      audioId: audioUrl?.split('/').pop()
    });
    
    // Store transcription for audit trail
    const transcriptionId = await storeTranscription({
      sessionId,
      patientId,
      originalAudio: audioUrl || 'base64-encoded',
      transcription: transcription.text,
      segments: transcription.segments,
      language: transcription.language,
      confidence: transcription.confidence,
      processingTime: Date.now()
    });
    
    const response = {
      transcriptionId,
      text: transcription.text,
      segments: transcription.segments,
      language: transcription.language,
      confidence: transcription.confidence,
      timestamp: new Date().toISOString()
    };
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify(response)
    };
    
  } catch (error) {
    console.error('Transcription error:', error);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ 
        error: 'Transcription failed',
        message: error.message 
      })
    };
  }
}

/**
 * Handle text translation
 */
async function handleTranslation(requestData) {
  try {
    const { text, targetLanguage } = requestData;
    
    if (!text || typeof text !== 'string' || text.trim().length === 0) {
      return {
        statusCode: 400,
        headers: corsHeaders,
        body: JSON.stringify({ error: 'Text parameter is required' })
      };
    }
    
    if (!targetLanguage || typeof targetLanguage !== 'string') {
      return {
        statusCode: 400,
        headers: corsHeaders,
        body: JSON.stringify({ error: 'Target language parameter is required' })
      };
    }
    
    // Translate text
    const translation = await translateText(text.trim(), targetLanguage.toLowerCase());
    
    const response = {
      ...translation,
      originalText: text.trim(),
      timestamp: new Date().toISOString()
    };
    
    return {
      statusCode: 200,
      headers: corsHeaders,
      body: JSON.stringify(response)
    };
    
  } catch (error) {
    console.error('Translation error:', error);
    return {
      statusCode: 500,
      headers: corsHeaders,
      body: JSON.stringify({ 
        error: 'Translation failed',
        message: error.message 
      })
    };
  }
}